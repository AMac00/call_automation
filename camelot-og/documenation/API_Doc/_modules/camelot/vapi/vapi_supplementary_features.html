
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>camelot.vapi.vapi_supplementary_features &#8212; Camelot Python SDK v12.6.22.12.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Camelot Python SDK v12.6.22.12.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../camelot.html" accesskey="U">camelot</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for camelot.vapi.vapi_supplementary_features</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">camelot</span>
<span class="kn">from</span> <span class="nn">camelot.vapi</span> <span class="k">import</span> <span class="n">vapi_camelot_utils</span> <span class="k">as</span> <span class="n">v</span>
<span class="kn">from</span> <span class="nn">camelot</span> <span class="k">import</span> <span class="n">camlogger</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">camlogger</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CamelotSFeatureControl</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">CamelotVapiUtils</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;Camelot supplementary feature representation</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">blind_transfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">called</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Blind Transfer a call</span>

<span class="sd">        Do blind call transfer on Legacy SIP endpoints registered with CME.</span>

<span class="sd">        The invocation of this command puts the specified call on hold</span>
<span class="sd">        awaiting transfer.  A new outbound call is automatically generated from</span>
<span class="sd">        the Transferee to the, which will be destination of the transfer.</span>
<span class="sd">        After generating the new calldialing the destination number, the</span>
<span class="sd">        previous call that was put on hold is automatically disconnected.</span>
<span class="sd">        called argument can take DN or URI.</span>

<span class="sd">        :parameter call_ref: call reference</span>
<span class="sd">        :parameter called: called party address (DN or URI)</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.blind_transfer(0xf2c3a4a0,&#39;880002&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">BLIND_TRANSFER</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span>
                                    <span class="n">called</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cme_hw_conference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Add a call to a CME based hardware conference</span>

<span class="sd">        initiate/add a call to a hardware conference for the CME interfacing</span>
<span class="sd">        SIP endpoints. The CME interfacing can be configured using</span>
<span class="sd">        sip.registrar.isCM is set to 2. If the specified call is not a</span>
<span class="sd">        hardware conference call, then invocation of this method changes</span>
<span class="sd">        the specified call to a hardware conference call, puts it on hold,</span>
<span class="sd">        and automatically generates a new outbound call. Client code can</span>
<span class="sd">        then setup this new call (using dial command on this new outbound call)</span>
<span class="sd">        and execute cmehwconference for a second time to add the new call to</span>
<span class="sd">        the existing hardware conference. This will resume the hardware</span>
<span class="sd">        conference call and new call will get disconnected by CME.</span>

<span class="sd">        :parameter call_ref: call reference.</span>

<span class="sd">        :returns: True on Success.</span>

<span class="sd">        &gt;&gt;&gt; ep.cme_hw_conference(0xf2c3a4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">CME_HW_CONFERENCE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">park</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Park a call</span>

<span class="sd">        Parks an active call to a number designated via the CCM configuration.</span>
<span class="sd">        The parked call is automatically disconnected.</span>
<span class="sd">        It is supported for both sipx and jabbermobile endpoints for both</span>
<span class="sd">        deployments On-Premise and Collab-Edge.</span>

<span class="sd">        :parameter call_ref: call reference is mandatory</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.park(0xf2c3a4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; retrieving the parked call.</span>
<span class="sd">        &gt;&gt;&gt; ep.placecall(&#39;parked_number&#39;)</span>
<span class="sd">        Oxfe12434</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">PARK</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pickup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;pickup a call</span>
<span class="sd">        Picks up a call inbound on another phone in the same CCM</span>
<span class="sd">        configured group.  To answer a call bound to another endpoint</span>
<span class="sd">        within your call pickup group, first initiate a new call, then</span>
<span class="sd">        invoke pickup.  The inbound call will be directed to this endpoint,</span>
<span class="sd">        and a new inbound call will be present.  The current call is</span>
<span class="sd">        automatically disconnected.</span>

<span class="sd">        Some CCMs may enable calls to be picked up without first initiating</span>
<span class="sd">        a new outbound call.  In this case, the call reference argument is</span>
<span class="sd">        optional.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.pickup(0xf2c3a4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not valid&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">PICKUP</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">gpickup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;pickup a call</span>

<span class="sd">        Same as the pickup command, except it allows one to pick up calls</span>
<span class="sd">        targeted to an associated group. To answer a call bound to an endpoint</span>
<span class="sd">        in a different call pickup group, first initiate a new call then invoke</span>
<span class="sd">        gpickup.  Dial the desired call pickup group number.  The inbound call</span>
<span class="sd">        will be directed to this endpoint, and a new inbound call will be</span>
<span class="sd">        present.  The current call is automatically disconnected.</span>

<span class="sd">        Some CCMs may enable calls to be picked up without first initiating</span>
<span class="sd">        a new outbound call.  In this case, the call reference argument is</span>
<span class="sd">        optional.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.gpickup(0xf2c3a4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not valid&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">GPICKUP</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">cell_pickup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;pickup a call</span>

<span class="sd">        Cellpickup is used to send the currently connected call to the</span>
<span class="sd">        remote destination of that phone. If the call reference is not</span>
<span class="sd">        mentioned then the current mobility status of the phone will be</span>
<span class="sd">        fetched from the CCM and could be retrieved through getstationevent.</span>


<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.cell_pickup(0xf2c3a4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">CELL_PICKUP</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">opickup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;pickup a call</span>
<span class="sd">        Same as the pickup command, except it allows one to pick up calls</span>
<span class="sd">        targeted to other pickup groups. To answer a call bound to an endpoint</span>
<span class="sd">        in a different call pickup group, first initiate a new call then invoke</span>
<span class="sd">        opickup.  Dial the desired call pickup group number.  The inbound call</span>
<span class="sd">        will be directed to this endpoint, and a new inbound call will be</span>
<span class="sd">        present.  The current call is automatically disconnected.</span>

<span class="sd">        Some CCMs may enable calls to be picked up without first initiating</span>
<span class="sd">        a new outbound call.  In this case, the call reference argument</span>
<span class="sd">        is optional.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.opickup(0xf2c3a4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">OPICKUP</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">send_user_answer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">         This command is used to send the explicit user answer notification</span>
<span class="sd">         and is supported for (cumc/dmc) endpoints. On issuing this command</span>
<span class="sd">         Camelot dmc endpoint would send an in-dialogue REFER message with the</span>
<span class="sd">         required xml body which indicates UCM that the call is answered by the</span>
<span class="sd">         user and not by voice mail.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.cell_pickup(0xf2c3a4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">SEND_USER_ANSWER</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_pref_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Updates the preferred mode of a dual mode single registration</span>
<span class="sd">          endpoint (dmc). The updated value will reflect in the REGISTER</span>
<span class="sd">          message sent to CUCM.</span>

<span class="sd">        :parameter mode: 0 - Cellular mode, 1- VOIP mode</span>

<span class="sd">        :returns: 0 - Cellular mode, 1- VOIP mode</span>

<span class="sd">        &gt;&gt;&gt; ep.set_pref_mode(1)</span>
<span class="sd">        1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;mode not specified/wrong mode&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">SET_PREF_MODE</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_call_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sets the call type parm and same thing is used when the next call</span>
<span class="sd">         is initiated on the DMC endpoint. This command is used to change the</span>
<span class="sd">         type of the next call to be initiated on the given DMC endpoint.</span>

<span class="sd">        :parameter mode: 0 - Cellular mode, 1- VOIP mode</span>

<span class="sd">        :returns: 0 - Cellular mode, 1- VOIP mode</span>

<span class="sd">        &gt;&gt;&gt; ep.set_call_type(1)</span>
<span class="sd">        1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;mode not specified/wrong mode&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">SET_CALL_TYPE</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_mobile_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Display the mobile identity of the endpoint and is applicable</span>
<span class="sd">         for (cumc) and (dmc) endpoints.</span>

<span class="sd">        :returns: returns mobile identity of the endpoint.</span>

<span class="sd">        &gt;&gt;&gt; ep.get_mobile_identity()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">GET_MOBILE_IDENTITY</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rmlstc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Remove last conference participant</span>

<span class="sd">        Removes the conference participant last added to the</span>
<span class="sd">        specified conference call.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.rmlstc(0xf2c3a4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">RMLSTC</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">meetme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initiate a meetme conference</span>

<span class="sd">        Initiates a meet-me conference on an outbound call.  To initiate a</span>
<span class="sd">        meetme conference, initiate a new call by invoking newcall or offhook.</span>
<span class="sd">        Then invoke meetme and then dial the meetme conference number.</span>
<span class="sd">        Removes the conference participant last added to the</span>
<span class="sd">        specified conference call. meetme uri is picked up from</span>
<span class="sd">        sip.phone.sip_call_features.meetme_service_uri config parm.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.meetme(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">MEETME</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">redial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initiate a call to last called party</span>

<span class="sd">        Initiate a call to the last called address dialed.</span>


<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.meetme(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">REDIAL</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; returns the Hedge token associated with endpoint</span>

<span class="sd">        :returns: On success returns the Hedge token associated with</span>
<span class="sd">         the endpoint, else returns enpty string</span>

<span class="sd">        &gt;&gt;&gt; ep.get_token()</span>
<span class="sd">        testuser_ep2@gmail.com_DEADBEEF1235</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">GET_TOKEN</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call_fwd_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Forward all inbound calls</span>

<span class="sd">        Inform CCM of called address to forward all inbound calls.</span>
<span class="sd">        Upon executing this command a new outbound call is created.</span>
<span class="sd">        Then use the dial method to send the called address</span>
<span class="sd">        (called address can be DN or URI) to CCM.  Once complete, the call is</span>
<span class="sd">        automatically disconnected.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.call_fwd_all(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">CFWDALL</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">idivert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">eidivert_dest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Divert an inbound call</span>


<span class="sd">        :parameter call_ref: call reference</span>
<span class="sd">        :parameter eidivert_dest: enhanced destination number or &#39;Cancel&#39;</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.idivert(&#39;0xf16cc830&#39;) # passing call reference</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ep2.idivert(&#39;0xf16cc830&#39;, &#39;36001&#39;) # passing</span>
<span class="sd">        call reference and enhanced idivert destination to be diverted</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">IDIVERT</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">eidivert_dest</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">barge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Barge into a call on a shared line</span>

<span class="sd">        Join an active call on a shared line using conferencing resources on</span>
<span class="sd">        the target endpoint.  The call specified must be in the remoteinuse</span>
<span class="sd">        state.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success and exception on failure</span>

<span class="sd">        &gt;&gt;&gt; ep.barge(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">BARGE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cbarge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Barge into a call on a shared line converting the call to a</span>
<span class="sd">        conference call</span>

<span class="sd">        Join an active call on a shared line using shared conferencing</span>
<span class="sd">        resources.  The barge call becomes a standard conference call.</span>
<span class="sd">        The call specified must be in the remoteinuse state.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.cbarge(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">CBARGE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Select calls for subsequent invocation of a supplementary service</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.meetme(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">SELECT</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">privacy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Toggle privacy on/off for an endpoint sharing a line</span>

<span class="sd">        Toggle privacy on/off for the specified endpoint.</span>
<span class="sd">        This can be invoked only on a shared line.</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.privacy()</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">PRIVACY</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Join selected calls into an ad hoc conference</span>

<span class="sd">        Join the specified call and other selected calls into an</span>
<span class="sd">        ad hoc conference.</span>
<span class="sd">        See also ep.select.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.join(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">JOIN</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">direct_transfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Transfer two selected calls to each other</span>

<span class="sd">        Directly transfer two selected calls to each other.</span>
<span class="sd">        The call reference specified should be one of the selected calls.</span>


<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.direct_transfer(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DIRECT_TRANSFER</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get notified when a called party is available</span>

<span class="sd">        Inform CCM to alert endpoint when remote party becomes available.</span>


<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.callback(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">CALL_BACK</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">conflist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get a list of conference participants</span>

<span class="sd">        Get CCM to send a list of conference participants.</span>
<span class="sd">        This information is returned via userdata station event.</span>


<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.conflist(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">CONFLIST</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">flash_length</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">time_out</span><span class="o">=</span><span class="mi">2000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For Skinny endpoints,</span>
<span class="sd">        It sends flash softkey event to CCM.</span>
<span class="sd">        It actually sends StationSoftKeyEventMessage to CCM</span>
<span class="sd">        to simulate hookflash</span>

<span class="sd">        For CAS endpoints,</span>
<span class="sd">        It invokes DivaSendFlash.</span>

<span class="sd">        :parameter call_ref: reference for the call. Its mandatory param.</span>

<span class="sd">        :parameter flash_length: flash length, Only needed for CAS endpoints.</span>
<span class="sd">         default value &#39;500&#39; will be set on absence of this value.</span>

<span class="sd">        :parameter time_out: time out , Only needed for CAS endpoints</span>
<span class="sd">         default value is &#39;2000&#39; (in millisecond) will be set on</span>
<span class="sd">         absence of this value.</span>

<span class="sd">        :returns: True On success.</span>

<span class="sd">        For skinny endpoints this API returns</span>
<span class="sd">        immediately on success or failure. But for CAS endpoints, after</span>
<span class="sd">        successful processing of Diva API it does not return immediately.</span>
<span class="sd">        For CAS, this API will return only when &#39;DivaEventFlashCompleted&#39;</span>
<span class="sd">        is received by Camelot from Diva Board. In case this event is</span>
<span class="sd">        not received, this API will wait for &quot;time_out&quot; duration and</span>
<span class="sd">        will throw Camelot Error.</span>

<span class="sd">        Please refer the following wiki link to know different possible</span>
<span class="sd">        return texts on failure (only for CAS endpoints).</span>
<span class="sd">        `&lt;https://wiki.cisco.com/display/CAMELOT/Analog+ATA-190+Voice+Support#</span>
<span class="sd">        AnalogATA-190VoiceSupport-SupportofHookFlashfunctionalityinCamelot&gt;`_</span>

<span class="sd">        &gt;&gt;&gt; ep.flash(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ep.flash(0xf2c3c4a0,flash_length=300, time_out=2500)</span>
<span class="sd">        True</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flash_length</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_integer</span><span class="p">(</span><span class="n">flash_length</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;invalid flash_length&#39;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">time_out</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_integer</span><span class="p">(</span><span class="n">time_out</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;invalid time_out&#39;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;flash_length&#39;</span><span class="p">:</span> <span class="n">flash_length</span><span class="p">,</span>
                  <span class="s1">&#39;time_out&#39;</span><span class="p">:</span> <span class="n">time_out</span>
                  <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">FLASH</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">hlog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Send hlog softkey event to CCM</span>

<span class="sd">        Sends StationSoftKeyEventMessage to CCM to activate or deactivate</span>
<span class="sd">        &#39;Logged into Hunt Group&#39;. If the line is logged out of Hunt Group,</span>
<span class="sd">        no incoming call is allowed when a call comes to the line group.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.hlog(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not valid&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">HLOG</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Send record softkey event only for Chaperone Call to CUCM</span>

<span class="sd">        Sends StationSoftKeyEventMessage to CUCM for SCCP Phones with</span>
<span class="sd">        appropriate index. Sends &#39;StartRecording&#39; softkey REFER message</span>
<span class="sd">        with XML content to the CUCM for SIPX and RT Phones.</span>
<span class="sd">        For example, Chaperone connected Calls.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.record(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not valid&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">RECORD</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">live_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Send liverecord softkey event to CCM</span>


<span class="sd">        Sends StationSoftKeyEventMessage to CCM to start the live</span>
<span class="sd">        recording of the connected call.</span>


<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.live_record()</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">LIVE_RECORD</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">stop_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Send stoprecord softkey event only for SIPX and RT phones to CUCM</span>

<span class="sd">        Send &#39;StopRecording&#39; softkey REFER message with XML content to the CUCM</span>
<span class="sd">        for SIPX and RT Phones when recording is already in progress.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.stop_record(call_ref)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">STOP_RECORD</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">transfer_vm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Send transfervm softkey event to CCM</span>

<span class="sd">        Sends StationSoftKeyEventMessage to CCM to transfer to Voice mail.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.transfer_vm()</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">TRANSFER_VM</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">login</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Send login softkey event</span>

<span class="sd">        Sends login StationSoftKeyEventMessage. A callref is created after</span>
<span class="sd">        getting response from the gateway. Use get_calls to get the call_ref.</span>
<span class="sd">        Then use the dial command with the call_ref for sending the</span>
<span class="sd">        pin in the called filed.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep1.login</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; after 500</span>
<span class="sd">        &gt;&gt;&gt; ep1.get_calls</span>
<span class="sd">        [{&#39;0x010a5650&#39;: &#39;1&#39;: &#39;dialtone&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep1.dial(4321, 0x010a5650)</span>
<span class="sd">        True</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># FIXME: This might fail</span>
        <span class="c1"># if call_ref and not self._is_valid_call_ref(call_ref):</span>
        <span class="c1">#    raise camelot.CamelotError(&#39;Invalid call reference&#39;)</span>

        <span class="c1"># else:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">LOGIN</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">start_fax_send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initiate T.30 fax send operation</span>

<span class="sd">        :parameter callref:    call reference</span>
<span class="sd">        :parameter url:  URL of TIFF file to send</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep1.start_fax_send(&#39;0x1232af2&#39;, &quot;/home/camelot/diva/sendfax.tiff&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;filename not specified&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">START_FAX_SEND</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">start_fax_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initiate T.30 fax send operation</span>

<span class="sd">        :parameter callref: call reference</span>
<span class="sd">        :parameter prefix:  string to prepend to the received TIFF file.</span>
<span class="sd">                            This is mandatory if filename not given.</span>
<span class="sd">        :parameter filename: Name of the file with absolute path,</span>
<span class="sd">                             provided the file will be saved here.</span>
<span class="sd">                             If  not provided, by default received file</span>
<span class="sd">                             will be stored in</span>
<span class="sd">                             /usr/local/camelot/lib/recordings/</span>
<span class="sd">                             with the prefix added to the source file name.</span>
<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep2.vapi.start_fax_receive(&#39;0x12ef231&#39;, &quot;ep2&quot;,</span>
<span class="sd">        &quot;/root/tmp/myfax.tiff&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># FIXME: This method also might fail verify and fix</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;prefix not specified&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">START_FAX_RECEIVE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span>
                                <span class="n">filename</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">intercom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_ref</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">called</span><span class="o">=</span><span class="s1">&#39;null&#39;</span><span class="p">,</span> <span class="n">calling</span><span class="o">=</span><span class="s1">&#39;null&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Make an intercom call on intercom line</span>

<span class="sd">        Make a intercom call from caller&#39;s intercom line to callee&#39;s</span>
<span class="sd">        intercomline. Both caller and callee&#39;s DNs has to be in the same</span>
<span class="sd">        Intercom Partition and Intercom CSS. Currently, camelot server support</span>
<span class="sd">        the intercom speeddial feaure only on SCCP endpoints,but not on SIP</span>
<span class="sd">        endpoints. Hence the &#39;called&#39; commandline option is optional for the</span>
<span class="sd">        former but not the later. We will implement the same feature for SIP</span>
<span class="sd">        in next release.</span>

<span class="sd">        So for SCCP endpoints, there are ways of using this command:</span>

<span class="sd">            (1) endp.intercom(line_ref=caller-intercom-line-number,</span>
<span class="sd">            called=callee-intercom-DN) or</span>
<span class="sd">            (2) endp.intercom(lineref=caller-intercom-line-number)</span>
<span class="sd">            Where in case (2), caller&#39;s intercom line must have a speed dial</span>
<span class="sd">            configured with callee&#39;s intercom DN. Or else, camelot server will</span>
<span class="sd">            reject the call.</span>

<span class="sd">        For SIP endpoints, only case (1) applies. This will change once we</span>
<span class="sd">        implement the speed dial feature for SIP endpoints.</span>

<span class="sd">        For SCCP endpoints, there is another way to invoke intercom feature:</span>
<span class="sd">            endp.select_line(lineref=&#39;caller-intercom-line-number&#39;)</span>
<span class="sd">            and then use the call_ref returned by this in the next dial</span>
<span class="sd">            command,</span>
<span class="sd">            endp.dial(call_ref=call_ref1, called= callee-intercom-DN)</span>

<span class="sd">        However, it is unsupported for SIPX endpoints.</span>

<span class="sd">        :parameter line_ref: line number of the configured intercom line</span>
<span class="sd">        :parameter called: DN of calle&#39;s intercom line.</span>
<span class="sd">                Optional for SCCP endpoint but required for SIP endpoints.</span>

<span class="sd">        :returns: call reference for caller&#39;s endpoint</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;called&#39;</span><span class="p">:</span> <span class="n">called</span><span class="p">,</span>
                  <span class="s1">&#39;calling&#39;</span><span class="p">:</span> <span class="n">calling</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">INTERCOM</span><span class="p">,</span> <span class="n">line_ref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">talk_back</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Establish a two way communication between caller and callee</span>
<span class="sd">        who were engaged in an open way intercom call.</span>

<span class="sd">        The callee of an established one-way intercom call uses this method to</span>
<span class="sd">        change the existing call into a two way call. Note, only the callee can</span>
<span class="sd">        initiate this method, not the caller.</span>


<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.callback(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">TALK_BACK</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">mute</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Move a connected call on a CUMC endpoint to the shared line</span>

<span class="sd">        The CUMC endpoint uses this method to move an established call</span>
<span class="sd">        to the shared line.</span>


<span class="sd">        :parameter call_ref: call reference</span>
<span class="sd">        :parameter mute: disable or enable the mute</span>
<span class="sd">            * 0 - disable mute (default value)</span>
<span class="sd">            * 1 - enable mute</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.move(0xf2c3c4a0)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">mute</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">mute</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
            <span class="n">mute</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mute</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mute&#39;</span><span class="p">:</span> <span class="n">mute</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">MOVE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send_reinvite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">w_last_sdp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initiates sip Re-Invite with SDP for a given call</span>

<span class="sd">        :parameter call_ref: The call reference</span>
<span class="sd">        :parameter w_last_sdp:</span>
<span class="sd">         * 1- send Re-Invite with last sent SDP(default)</span>
<span class="sd">         * 0 - send with new configured SDP codecs</span>

<span class="sd">        :returns: True on success  otherwise False is returned. For error</span>
<span class="sd">            the CamelotError exception is raised</span>

<span class="sd">        &gt;&gt;&gt; ep1.send_reinvite(&#39;0x010a5650&#39;, 1 )</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method send_reinvite().&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">w_last_sdp</span> <span class="ow">and</span> <span class="n">w_last_sdp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">w_last_sdp</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w_last_sdp</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;last_sdp&#39;</span><span class="p">:</span> <span class="n">w_last_sdp</span><span class="p">,</span> <span class="s1">&#39;timeout&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">timeout</span><span class="p">)}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">SEND_REINVITE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start_share</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">secvidtype</span><span class="o">=</span><span class="s2">&quot;slides&quot;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        once the call is established with BFCP m=line negotiated,</span>
<span class="sd">        start_share() will initiate start share procedures, which includes</span>
<span class="sd">        BFCP floorctrl messages and SIP Re-Invite for secondary presentation</span>
<span class="sd">        video.</span>
<span class="sd">        The type of presentation is specified in secvidtype parameter.</span>

<span class="sd">        :parameter call_ref: reference of the call</span>
<span class="sd">        :parameter secvidtype: optional string type parameter\n</span>
<span class="sd">         * if secvidtype parameter omitted, default will be &quot;slides&quot;</span>
<span class="sd">         * secvidtype parameter value can be:</span>
<span class="sd">             * slides</span>
<span class="sd">             * speakar</span>
<span class="sd">             * alt</span>
<span class="sd">             * content</span>

<span class="sd">        :returns: True on success  otherwise False is returned.</span>
<span class="sd">                 For error the CamelotError exception is raised</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;secvidtype&#39;</span><span class="p">:</span> <span class="n">secvidtype</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">START_SHARE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stop_share</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">secvidtype</span><span class="o">=</span><span class="s2">&quot;slides&quot;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        once the call is established with BFCP m=line and seconday video</span>
<span class="sd">        m=line, stop_share() will initiate stop share procedures, which</span>
<span class="sd">        includes BFCP floorctrl messages and SIP Re-Invite for secondary</span>
<span class="sd">        presentation video.</span>
<span class="sd">        The type of presentation is specified in secvidtype parameter.</span>

<span class="sd">        :parameter call_ref: reference of the call</span>
<span class="sd">        :parameter secvidtype: optional string type parameter\n</span>
<span class="sd">         * if secvidtype parameter omitted, default will be &quot;slides&quot;</span>
<span class="sd">         * secvidtype parameter value can be:</span>
<span class="sd">             * slides</span>
<span class="sd">             * speakar</span>
<span class="sd">             * alt</span>
<span class="sd">             * content</span>

<span class="sd">        :returns: True on success  otherwise False is returned.</span>
<span class="sd">                 For error the CamelotError exception is raised</span>

<span class="sd">        &gt;&gt;&gt; ep1.stop_share()</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;secvidtype&#39;</span><span class="p">:</span> <span class="n">secvidtype</span>
                  <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">STOP_SHARE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dtmf_hold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        After call connect user need to execute command dtmf_hold.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        &gt;&gt;&gt; ep.dtmf_hold( call_ref=&#39;call_ref-value&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not specified&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">call_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_hex_to_int</span><span class="p">(</span><span class="n">call_ref</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DTMF_HOLD</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dtmf_resume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Hold calls (using DTMF) can be resumed by dtmf_resume command.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        &gt;&gt;&gt; ep.dtmf_resume(call_ref=&#39;call_ref-value&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not specified&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">call_ref</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">call_ref</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DTMF_RESUME</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dtmf_exclusive_hold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Exclusive hold is required , when end points needs to dial</span>
<span class="sd">        for a new call. This is required to to realize call</span>
<span class="sd">        transfer / conference scenarios, where user needs to dial</span>
<span class="sd">        to a new call.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        &gt;&gt;&gt; ep.dtmf_exclusive_hold(call_ref=&#39;call_ref-value&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not specified&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">call_ref</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">call_ref</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DTMF_EXCLUSIVE_HOLD</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dtmf_dust</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;The complete dusting feature can move single call,</span>
<span class="sd">        conference, and session collaboration among mobile phone,</span>
<span class="sd">        PC, and desk phone. To get more understanding on dusting please</span>
<span class="sd">        refer EDCS-804326.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        &gt;&gt;&gt; ep.dtmf_dust(call_ref=&#39;call_ref-value&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not specified&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">call_ref</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">call_ref</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DTMF_DUST</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dtmf_transfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Call transfer (in DTMF smart mode) can be achieved similar way as</span>
<span class="sd">        that of legacy call transfer. Lets take an example to explain the</span>
<span class="sd">        steps to get dtmf transfer working. Assume there are three phones,</span>
<span class="sd">        A, B and C. A calls B, A and B are connected. Now A invokes</span>
<span class="sd">        dtmf_transfer, A-B call goes to held state. A gets dial tone.</span>
<span class="sd">        A dials to new phone C and now A and C are connected. Again A</span>
<span class="sd">        invokes dtmf_transfer using connected call reference to complete</span>
<span class="sd">        the transfer. After this two calls at A get disconnected,</span>
<span class="sd">        B-C call gets connected.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        &gt;&gt;&gt; ep.dtmf_transfer(call_ref=&#39;call_ref-value&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not specified&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">call_ref</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">call_ref</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DTMF_TRANSFER</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dtmf_conference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Call conference (in DTMF smart mode) works similar to legacy</span>
<span class="sd">        conference way. Lets take an example to explain the steps to get</span>
<span class="sd">        dtmf_conference working. Assume there are three phones, A, B and C.</span>
<span class="sd">        A calls B, A and B are connected. Now A invokes dtmf_conference,</span>
<span class="sd">        A-B call goes to held state. A gets dial tone. A dials to new phone C</span>
<span class="sd">        and now A and C are connected. Again A invokes dtmf_conference using</span>
<span class="sd">        connected call reference to complete the conference. After this, A, B</span>
<span class="sd">        and C are in conference each having a single call.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: 1 on success 0 on failure.</span>

<span class="sd">        &gt;&gt;&gt; ep.dtmf_conference(call_ref=&#39;call_ref-value&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not specified&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">call_ref</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">call_ref</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DTMF_CONFERENCE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_timing_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Enable the timing to check how much time spent for particular</span>
<span class="sd">           method to get it complete</span>

<span class="sd">        :parameter method: method name for which timing need to calculate</span>
<span class="sd">            (e.g inservice, uxnssologin, ucmssologin, uxnssoredirect,</span>
<span class="sd">            ucmssoredirect, uxnssopostcredrential, ucmssopostcredrential).</span>

<span class="sd">        :returns: Upon success returns the timing stats or else error msg</span>
<span class="sd">        &gt;&gt;&gt; ep1.get_timing_stats(inservice or uxnssologin or ucmssologin</span>
<span class="sd">             or uxnssoredirect or ucmssoredirect or uxnssopostcredrential</span>
<span class="sd">             or ucmssopostcredrential)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">method_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;inservice&#39;</span><span class="p">:</span>
            <span class="n">method_id</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;uxnssologin&#39;</span><span class="p">:</span>
            <span class="n">method_id</span> <span class="o">=</span> <span class="s1">&#39;2&#39;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ucmssologin&#39;</span><span class="p">:</span>
            <span class="n">method_id</span> <span class="o">=</span> <span class="s1">&#39;3&#39;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;uxnssoredirect&#39;</span><span class="p">:</span>
            <span class="n">method_id</span> <span class="o">=</span> <span class="s1">&#39;4&#39;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ucmssoredirect&#39;</span><span class="p">:</span>
            <span class="n">method_id</span> <span class="o">=</span> <span class="s1">&#39;5&#39;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;uxnssopostcredential&#39;</span><span class="p">:</span>
            <span class="n">method_id</span> <span class="o">=</span> <span class="s1">&#39;6&#39;</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ucmssopostcredential&#39;</span><span class="p">:</span>
            <span class="n">method_id</span> <span class="o">=</span> <span class="s1">&#39;7&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Unknown method type&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">GET_TIMING_STATS</span><span class="p">,</span> <span class="n">method_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">escalate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">option</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This command will be used after the call is connected, to promote the</span>
<span class="sd">        new media on top of the existing media by using option parameter.</span>

<span class="sd">        :parameter call_ref: reference of the call</span>
<span class="sd">        :parameter option: it is string type parameter.</span>
<span class="sd">                           It tells, what type of media is being</span>
<span class="sd">                           escalated/deescalated.</span>
<span class="sd">                           if the initial call is</span>
<span class="sd">                           &quot;audio+video+fecc+bfcp+slides&quot;</span>
<span class="sd">                           and option = &quot;audio+video+fecc+ix&quot;,</span>
<span class="sd">                           SDP in the reinvite shall have audio, video, fecc,</span>
<span class="sd">                           ix m-lines with non zero port and</span>
<span class="sd">                           bfcp, slides m-lines with zero port</span>


<span class="sd">        :returns: True on success  otherwise False is returned.</span>
<span class="sd">                 For error the CamelotError exception is raised</span>

<span class="sd">        &gt;&gt;&gt; ep1.escalate(&#39;0xe8faf034&#39;,option=&quot;audio&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not valid&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">ESCALATE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deescalate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">option</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This command will be used after the call is connected,</span>
<span class="sd">        to deescalate the media using option parameter.</span>

<span class="sd">        :parameter call_ref: reference of the call</span>
<span class="sd">        :parameter option: tells, what type of media is being deescalated.</span>
<span class="sd">                           if the initial call is</span>
<span class="sd">                           &quot;audio+video+fecc+bfcp+slides&quot;</span>
<span class="sd">                           and option = &quot;audio+video&quot;,</span>
<span class="sd">                           SDP in the reinvite shall have audio, video</span>
<span class="sd">                           m-lines with non zero port and</span>
<span class="sd">                           fecc, bfcp, slides m-lines with zero port</span>

<span class="sd">        :returns: True on success  otherwise False is returned.</span>
<span class="sd">            For error the CamelotError exception is raised</span>

<span class="sd">        &gt;&gt;&gt; ep1.deescalate(&#39;0xf1f6d034&#39;,option=&quot;audio+video&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not valid&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DEESCALATE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sets or gets the specified configuration parameter.</span>

<span class="sd">        :parameter header: name of the header</span>
<span class="sd">        :parameter value: value to be set</span>

<span class="sd">        :returns: &#39;1&#39; in case of success and &#39;0&#39; in case of failure</span>

<span class="sd">        &gt;&gt;&gt; ep1.config_header(&#39;Allow&#39;,&#39;ACK,BYE,CANCEL,INVITE&#39;)</span>
<span class="sd">        1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;param&#39;</span><span class="p">:</span> <span class="n">param</span><span class="p">,</span>
                  <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">value</span>
                  <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">CONFIG_HEADER</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">refresh_template_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;refresh the template message stored in camelot.</span>

<span class="sd">        :parameter method: The name of the method which user wants</span>
<span class="sd">            to refresh. If no parameter is given, it will refresh all</span>
<span class="sd">            the methods stored in camelot.</span>

<span class="sd">        :returns: 1 on success 0 on failure.</span>

<span class="sd">        &gt;&gt;&gt; ep.refresh_template_message(method)</span>
<span class="sd">        1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">REFRESH_TEMPLATE_MESSAGE</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">move_to_mobile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Move a call from VoIP to Cellular side.</span>

<span class="sd">        Move a connected call in a DMC (or jabber mobile) endpoint</span>
<span class="sd">        (attended in VoIP mode), from IP to GSM.</span>
<span class="sd">        Its supported for both deployments On-Premise and Collab Edge.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: 1 on success</span>

<span class="sd">        &gt;&gt;&gt; ep.move_to_mobile(&#39;0xf1706408&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method move_to_mobile().&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;call reference not specified&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">MOVE_TO_MOBILE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exec_mediator_cmd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        accepts the command from the user and passes the same</span>
<span class="sd">        on to the mediator. Depending upon the output</span>
<span class="sd">        configuaration the camelot either to wait for the</span>
<span class="sd">        response from mediator or returns immediately without</span>
<span class="sd">        wiating.returns error string if the mediator is not running.</span>

<span class="sd">        :parameter cmd: mandatory parameter. command to be passed to</span>
<span class="sd">         mediator application.</span>
<span class="sd">         if the command takes multiple arguements then provide them</span>
<span class="sd">         in the this parameter. one example can be &quot;startrectpat video</span>
<span class="sd">         1920 1000 30&quot;. The set of supported mediator commands can be</span>
<span class="sd">         found here https://pypi.lal.cisco.com/doc/phone-e/mediator.html.</span>
<span class="sd">        :parameter output: accepts 0 or 1. 0 can be given when the user</span>
<span class="sd">         just want to pass the command to mediator but not expecting the</span>
<span class="sd">         response from mediator. 1 can be given when the user expecting</span>
<span class="sd">         to get the response returned by the mediator.</span>
<span class="sd">        :parameter delay: It accepts the delay time in seconds and defaults</span>
<span class="sd">         to 10 decs.This parameter has the significance only when the</span>
<span class="sd">         user set the output parameter to 1 otherwise this value will</span>
<span class="sd">         be ignored. it says how long the Camelot need to wait for</span>
<span class="sd">         the response to receive from mediator before returning to</span>
<span class="sd">         the user. if set with -1 then the camelot will wait infinitely</span>
<span class="sd">         to receive the response.</span>

<span class="sd">        :returns: If output parameter was set to 0 then the return will be</span>
<span class="sd">         either 0 or 1, on success 1 will be returned otherwise 0.</span>
<span class="sd">         if the output is set to 1 then the camelot returns the response</span>
<span class="sd">         in the format returned by the mediator.</span>

<span class="sd">        &gt;&gt;&gt; ep1.exec_mediator_cmd(&quot;enable audio&quot;)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; ep1.exec_mediator_cmd(&quot;audiosample,1,10)</span>
<span class="sd">        audiosampleresult 8000 [-1564,-1980,-2108,-1980,-1564,-1052,-396,</span>
<span class="sd">        308,988,1500,1884,2108,1980,1628,1116,460,-244,-924,-1500,-1884,-2108,</span>
<span class="sd">        -1980,-1692,-1180,-524,180,876,1436,1820,1980,1980,1692,1244,588,-120,</span>
<span class="sd">        -812,-1372,-1820,-1980,-1980,-1756,-1244,-652,48,748,1372,1820,1980,</span>
<span class="sd">        1980,1756,1308,716,16,-684,-1308,-1756,-1980,-1980,-1820,-1372,-780,</span>
<span class="sd">        -80,620,1244,1756,1980,1980,1820,1436,812,148,-556,-1180,-1692,-1980,</span>
<span class="sd">        -2108,-1884,-1436,-876,-212,]</span>
<span class="sd">        &gt;&gt;&gt; ep1.exec_mediator_cmd(&quot;enable video&quot;)</span>
<span class="sd">        mediator not running</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cmd&#39;</span><span class="p">:</span> <span class="n">cmd</span><span class="p">,</span>
                  <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="n">output</span><span class="p">,</span>
                  <span class="s1">&#39;delay&#39;</span><span class="p">:</span> <span class="n">delay</span>
                  <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">EXEC_MEDIATOR_CMD</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start_raw_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callid_filter</span><span class="p">,</span> <span class="n">method_filter</span><span class="p">,</span> <span class="n">cseq_filter</span><span class="p">,</span>
                         <span class="n">assist</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;callid_filter&#39;</span><span class="p">:</span> <span class="n">callid_filter</span><span class="p">,</span>
                  <span class="s1">&#39;method_filter&#39;</span><span class="p">:</span> <span class="n">method_filter</span><span class="p">,</span>
                  <span class="s1">&#39;cseq_filter&#39;</span><span class="p">:</span> <span class="n">cseq_filter</span><span class="p">,</span>
                  <span class="s1">&#39;assist&#39;</span><span class="p">:</span> <span class="n">assist</span>
                  <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">START_RAW_EVENTS</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stop_raw_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callid_filter</span><span class="p">,</span> <span class="n">method_filter</span><span class="p">,</span> <span class="n">cseq_filter</span><span class="p">,</span>
                        <span class="n">assist</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;callid_filter&#39;</span><span class="p">:</span> <span class="n">callid_filter</span><span class="p">,</span>
                  <span class="s1">&#39;method_filter&#39;</span><span class="p">:</span> <span class="n">method_filter</span><span class="p">,</span>
                  <span class="s1">&#39;cseq_filter&#39;</span><span class="p">:</span> <span class="n">cseq_filter</span><span class="p">,</span>
                  <span class="s1">&#39;assist&#39;</span><span class="p">:</span> <span class="n">assist</span>
                  <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">STOP_RAW_EVENTS</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Camelot Python SDK v12.6.22.12.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../camelot.html" >camelot</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.
    </div>
  </body>
</html>