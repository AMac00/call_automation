
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>camelot.vapi.vapi_call_control &#8212; Camelot Python SDK v12.6.22.12.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Camelot Python SDK v12.6.22.12.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../camelot.html" accesskey="U">camelot</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for camelot.vapi.vapi_call_control</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">camelot</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">camelot.vapi</span> <span class="k">import</span> <span class="n">vapi_camelot_utils</span> <span class="k">as</span> <span class="n">v</span>
<span class="kn">from</span> <span class="nn">camelot</span> <span class="k">import</span> <span class="n">camlogger</span><span class="p">,</span> <span class="n">FaxProfile</span><span class="p">,</span> <span class="n">DivaFaxOptions</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">camlogger</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CamelotCallControl</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">CamelotVapiUtils</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;Camelot call control representation</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">release_calls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Release call resources</span>

<span class="sd">        Releases all resources consumed by the specified call.</span>
<span class="sd">        The call must be in the disconnected state. Upon successful completion,</span>
<span class="sd">        the specified call reference can no longer be used in future method</span>
<span class="sd">        invocations.  If -callref is omitted, all disconnected calls</span>
<span class="sd">        on the end point are released.</span>

<span class="sd">       :parameter call_ref: call reference</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">RELEASE_CALLS</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">release_call_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Release/decrement the reference count associated with a call.</span>

<span class="sd">        Decrements the Camelot server&#39;s reference count associated with a call.</span>
<span class="sd">        A call can not be released or deleted on the server unless its</span>
<span class="sd">        reference count is 0 or below. Currently a call&#39;s reference count is</span>
<span class="sd">        incremented when a call event of type start is sent to a client</span>
<span class="sd">        application. It is incremented once for each client receiving the</span>
<span class="sd">        event. It is the responsibility of each client to decrement the</span>
<span class="sd">        reference count via releasecallref when the client is done processing</span>
<span class="sd">        the call. This ensures the call is not deleted inadvertently via</span>
<span class="sd">        releasecalls or autorelease before the client can process the call.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: True on Success</span>

<span class="sd">        &gt;&gt;&gt; ep.release_call_ref(0x010a5650)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">RELEASE_CALLREF</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">release_streams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Release resources associated with the stream</span>

<span class="sd">        Releases all resources associated with the specified stream.</span>
<span class="sd">        The stream must be in the closed state.  Upon successful completion,</span>
<span class="sd">        the specified stream reference can no longer be used in future</span>
<span class="sd">        method invocations.  If -streamref is omitted, all closed streams</span>
<span class="sd">        on the endpoint are released.</span>

<span class="sd">        :parameter stream_ref: stream reference.  can be get from get_streams()</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">stream_ref</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">stream_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">RELEASE_STREAMS</span><span class="p">,</span> <span class="n">stream_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">onhook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Clicks on phones hookswitch</span>

<span class="sd">        Sends an onhook protocol message to disconnect a call. If successful,</span>
<span class="sd">        the call transitions to the disconnecting state and then to the</span>
<span class="sd">        disconnected state.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: 1 if onhook is successful else False</span>

<span class="sd">        &gt;&gt;&gt; ep1.onhook(&#39;0xf2c3a4a0&#39;)</span>
<span class="sd">        True</span>

<span class="sd">        Unknown call reference</span>

<span class="sd">        &gt;&gt;&gt; ep1.onhook(&#39;0xf2c3a4a&#39;)</span>
<span class="sd">        &#39;invalid call reference&#39;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">call_ref</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;call_ref&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">call_ref</span><span class="p">:</span>
            <span class="n">callref</span> <span class="o">=</span> <span class="n">call_ref</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">callref</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">ret_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">ONHOOK</span><span class="p">,</span> <span class="n">callref</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">offhook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initiate or answer a call</span>

<span class="sd">        Sends an off-hook protocol message to originate or answer a call</span>

<span class="sd">        If no arguments are specified, then an outbound call is attempted.</span>
<span class="sd">        Upon return, the outbound call will be in the outbound state.</span>
<span class="sd">        Once the off hook protocol message as been acknowledged</span>
<span class="sd">        (if necessary), the call will transition to the offhook state.</span>
<span class="sd">        Once the line has been seized, glare resolved, and dial tone</span>
<span class="sd">        detected, the call will progress to the dialtone state.</span>

<span class="sd">        To answer an inbound call, a call reference must be specified, and</span>
<span class="sd">        the specified call must be in the incoming state.  Upon success,</span>
<span class="sd">        the call transitions from the incoming state to the answering</span>
<span class="sd">        state and then to the connected state.</span>

<span class="sd">        For those call control protocols that do not support the notion of</span>
<span class="sd">        going off hook, call setup may not actually commence until</span>
<span class="sd">        the dial method is invoked.</span>

<span class="sd">        :parameter call_ref: call reference</span>

<span class="sd">        :returns: Upon success, the call reference of the new outbound or</span>
<span class="sd">         answered call is returned.  Otherwise False is returned.</span>

<span class="sd">        Offhook the endpoint</span>

<span class="sd">        &gt;&gt;&gt; ep1.offhook()</span>
<span class="sd">        &#39;0xf22076a8&#39;</span>

<span class="sd">        Offhook in failure</span>

<span class="sd">        &gt;&gt;&gt; ep1.offhook()</span>
<span class="sd">        False</span>

<span class="sd">        Calls on endpoint after offhook</span>

<span class="sd">        &gt;&gt;&gt; ep1.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;dialtone&#39;,</span>
<span class="sd">        &#39;Id&#39;: &#39;0xf22076a8&#39;,</span>
<span class="sd">        &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">        &#39;Ref&#39;: &#39;0xf22076a8&#39;}]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">call_ref</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;call_ref&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">call_ref</span><span class="p">:</span>
            <span class="n">callref</span> <span class="o">=</span> <span class="n">call_ref</span>
        <span class="k">if</span> <span class="n">callref</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">callref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;call reference not valid&#39;</span><span class="p">)</span>

        <span class="n">ret_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">OFFHOOK</span><span class="p">,</span> <span class="n">callref</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">newcall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lineref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Initiates a call</span>

<span class="sd">        Sends a newcall  protocol message to originate a new call</span>
<span class="sd">        Upon return, the outbound call will be in the outbound state.</span>
<span class="sd">        Once the newcall protocol message as been acknowledged (if necessary),</span>
<span class="sd">        the call will transition to the offhook state. Once the line has been</span>
<span class="sd">        seized, glare resolved, and dial tone detected, the call will progress</span>
<span class="sd">        to the dialtone state.  The new outbound call will be attempted on the</span>
<span class="sd">        specified line if a line reference is specified. Otherwise, the</span>
<span class="sd">        endpoint will choose which line to use.</span>

<span class="sd">        If the call control protocol has no newcall protocol message, this</span>
<span class="sd">        method is identical to offhook for outbound calls with the additional</span>
<span class="sd">        ability to specify the line for the outbound call.</span>

<span class="sd">        :returns: Upon success, the call reference of the new outbound call</span>
<span class="sd">         is returned.  Otherwise False is returned, and error information</span>
<span class="sd">         CamelotError exception is raised.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method newcall()&#39;</span><span class="p">)</span>
        <span class="n">line_ref</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;line_ref&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line_ref</span><span class="p">:</span>
            <span class="n">lineref</span> <span class="o">=</span> <span class="n">line_ref</span>
        <span class="k">if</span> <span class="n">lineref</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lineref</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span> <span class="ow">or</span> <span class="n">lineref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid line reference&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lineref</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">lineref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid line reference&#39;</span><span class="p">)</span>
        <span class="n">ret_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">NEWCALL</span><span class="p">,</span> <span class="n">lineref</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lineref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Send a line/feature button selection protocol message</span>

<span class="sd">        Sends a line selection  protocol message (for SCCP this is a station</span>
<span class="sd">        stimulus message).  Depending on the state of the line, this may</span>
<span class="sd">        generate a new outbound call if no call already exists on the specified</span>
<span class="sd">        line, disconnect an outbound call during setup, answer an inbound call</span>
<span class="sd">        if an incoming call exists on the specified line, or resume a call</span>
<span class="sd">        if a held call exists on the specified line. If the button is</span>
<span class="sd">        associated with any CCM feature, this sends a station stimulus message</span>
<span class="sd">        with the appropriate device stimulus.</span>

<span class="sd">        :parameter line_ref: line reference</span>

<span class="sd">        :returns: True or False</span>

<span class="sd">        &gt;&gt;&gt; ep.select_line(1)</span>
<span class="sd">        True</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method select_line()&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lineref</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lineref</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span> <span class="ow">or</span> <span class="n">lineref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid line reference&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lineref</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">lineref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid line reference&#39;</span><span class="p">)</span>
        <span class="n">ret_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">SELECT_LINE</span><span class="p">,</span> <span class="n">lineref</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select_plk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buttonref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;New command to initiate the CME HLog PLK Login/Logout</span>
<span class="sd">           Note:This command is applicable for only SCCP endpoints</span>

<span class="sd">        This command is only for SCCP endpoints,which are interfacing with CME.</span>
<span class="sd">        Sends a Station Stimulus SCCP protocol message. If the button is</span>
<span class="sd">        associated with any CME feature, this command sends a station stimulus</span>
<span class="sd">        message with the appropriate device stimulus data.</span>

<span class="sd">        :parameter button_ref: button index.  It can be get from get_info_ext()</span>

<span class="sd">        :returns: True or False</span>

<span class="sd">        &gt;&gt;&gt; ep.select_plk(1)</span>
<span class="sd">        True</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method select_plk()&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">buttonref</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">buttonref</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span> <span class="ow">or</span> <span class="n">buttonref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid button reference&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">buttonref</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">buttonref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid button reference&#39;</span><span class="p">)</span>
        <span class="n">ret_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">SELECT_PLK</span><span class="p">,</span> <span class="n">buttonref</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span>
               <span class="n">response_code</span><span class="o">=</span><span class="s1">&#39;403&#39;</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;Q.850;cause=21&#39;</span><span class="p">,</span> <span class="n">retry_after</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Reject an inbound call</span>

<span class="sd">        Reject an inbound call by allowing it to go unanswered.  Upon method</span>
<span class="sd">        invocation, the call transitions to the rejecting state and then</span>
<span class="sd">        to the disconnected state when the remote peer abandons the call.</span>

<span class="sd">        Some call control protocols may also support an active or forced</span>
<span class="sd">        reject mechanism where by the call is immediately disconnected</span>
<span class="sd">        rather than allowed to go unanswered.</span>

<span class="sd">        :parameter call_ref: - call reference</span>
<span class="sd">        :parameter response_code: - inbound call response code</span>
<span class="sd">        :parameter reason: - reason to reject the inbound call.</span>
<span class="sd">         If reason value is None then Camelot will not send Reason header.</span>
<span class="sd">        :parameter retry_after: - indicates how long(in seconds) the</span>
<span class="sd">         service/user is expected to be unavailable.</span>
<span class="sd">        :returns: True if successfully clicked, False in case of failure</span>

<span class="sd">        &gt;&gt;&gt; ep1.place_call(&#39;880002&#39;)</span>
<span class="sd">        &#39;0xb79fdd8&#39;</span>
<span class="sd">        &gt;&gt;&gt; ep1.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;alerting&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xb79fdd8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xb79fdd8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep2.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;incoming&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xb79fdd8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xb79fdd8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep2.reject(&#39;0xb79fdd8&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ep2.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;rejecting&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xb79fdd8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xb79fdd8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; time.sleep(5)</span>
<span class="sd">        &gt;&gt;&gt; ep2.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;disconnected&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xb79fdd8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xb79fdd8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep1.place_call(&#39;880002&#39;)</span>
<span class="sd">        &#39;0xb79fdd8&#39;</span>
<span class="sd">        &gt;&gt;&gt; ep1.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;alerting&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xb79fdd8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xb79fdd8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep2.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;incoming&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xb79fdd8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xb79fdd8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep2.reject(call_ref=&#39;0xb79fdd8&#39;,response_code=&#39;603&#39;,reason=&#39;None&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ep2.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;rejecting&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xb79fdd8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xb79fdd8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; time.sleep(5)</span>
<span class="sd">        &gt;&gt;&gt; ep2.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;disconnected&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xb79fdd8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xb79fdd8&#39;}]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method reject().&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;call reference not valid&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reason</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;reason is empty&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">response_code</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;response_code is empty&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;response_code&#39;</span><span class="p">:</span> <span class="n">response_code</span><span class="p">,</span>
                  <span class="s1">&#39;reason&#39;</span><span class="p">:</span> <span class="n">reason</span><span class="p">,</span>
                  <span class="s1">&#39;retry_after&#39;</span><span class="p">:</span> <span class="n">retry_after</span><span class="p">}</span>
        <span class="n">ret_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">REJECT</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dial_via_office</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callref</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">callbacknumber</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">called</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initiate a dial-via-office call placing on Camelot mobile clients.</span>

<span class="sd">        Initiate a dial-via-office specific call placing according to</span>
<span class="sd">        the specified mode.  For a new outbound call, this method will</span>
<span class="sd">        typically be called when the call progresses to the offhook and/or</span>
<span class="sd">        dialtone state.  Upon successful initiation of dialing and dial tone</span>
<span class="sd">        has been removed, the call progresses to the dialing state.  After</span>
<span class="sd">        addressing is complete and has been accepted by the remote end, the</span>
<span class="sd">        call progresses to the proceeding state.  Once the remote end is</span>
<span class="sd">        alerted of the new call and ring-back detected the call progresses to</span>
<span class="sd">        the alerting state.  After the remote end answers the call, the call</span>
<span class="sd">        progresses to the connected state.</span>

<span class="sd">        If the call mode is set to forward then the DID/Enterprise Feature</span>
<span class="sd">        Access number should be available via the getcallinfoext command.</span>
<span class="sd">        If the call mode is not set, by default, it executes reverse</span>
<span class="sd">        dialviaoffice. If the call mode is set to lcr , CUCM would apply the</span>
<span class="sd">        LCR rules configured on it and decides whether the call mode to be</span>
<span class="sd">        forward or reverse. Once the mode is decided the behavior of the</span>
<span class="sd">        call is same as the respective mode.   If callbackno is provided, then</span>
<span class="sd">        this line will receive the dialviaoffice reverse call instead of</span>
<span class="sd">        mobile client.</span>

<span class="sd">        mode with  lcrhandout will be applicable for DMC endpoints.Dmc calltype</span>
<span class="sd">        value shall be set to 0, before calling dialviaoffice with mode</span>
<span class="sd">        lcrhandout. The intension of lcrhandout is to switch the call from VoIP</span>
<span class="sd">        line to Cellular line on DMC endpoints.  Called parameter is</span>
<span class="sd">        optional for lcrhandout mode.</span>

<span class="sd">        :parameter callref: call reference of call</span>
<span class="sd">        :parameter called: called party address</span>
<span class="sd">        :parameter mode: call mode.  The possible values are \n</span>
<span class="sd">            * forward</span>
<span class="sd">            * reverse</span>
<span class="sd">            * lcr</span>
<span class="sd">            * lcrhandout</span>
<span class="sd">        :parameter callbackno: directory number of a non remote destination</span>
<span class="sd">                               to receive the call(applicable for dialviaoffice</span>
<span class="sd">                               reverse and lcr/reverse modes)</span>

<span class="sd">        :returns: True or False</span>

<span class="sd">        &gt;&gt;&gt; ep.dial_via_office(&#39;0xb79fdd8&#39;, &#39;forward&#39;, &#39;88001&#39;, &#39;88002&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">callref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call reference&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="ow">or</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="s1">&#39;reverse&#39;</span><span class="p">,</span> <span class="s1">&#39;lcr&#39;</span><span class="p">,</span> <span class="s1">&#39;lcrhandout&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid mode&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">called</span> <span class="ow">and</span> <span class="s1">&#39;lcrhandout&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;called number is not specified&#39;</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;called&#39;</span><span class="p">:</span> <span class="n">called</span><span class="p">,</span>
                  <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="n">mode</span><span class="p">,</span>
                  <span class="s1">&#39;callbackno&#39;</span><span class="p">:</span> <span class="n">callbacknumber</span><span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DIAL_VIA_OFFICE</span><span class="p">,</span> <span class="n">callref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dmchandin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">called</span><span class="o">=</span><span class="s1">&#39;null&#39;</span><span class="p">,</span> <span class="n">calling</span><span class="o">=</span><span class="s1">&#39;null&#39;</span><span class="p">,</span> <span class="n">calltype</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lineref</span><span class="o">=</span><span class="mi">0</span><span class="p">,):</span>
        <span class="sd">&#39;&#39;&#39; Switches call from cellular mode to Voip mode on DMC end points</span>

<span class="sd">        This command is used to switch the mode from cellular line to Voip line</span>
<span class="sd">        on a DMC end point. The call should  be made from the DMC end point</span>
<span class="sd">        to the mobile handoff number configured in the call manager. The</span>
<span class="sd">        calltype on the dual mode camelot client should be set to Voip i.e. 1,</span>
<span class="sd">        before invoking this command.On successful initiation the cellular call</span>
<span class="sd">        on the dual mode client will be disconnected and a Voip call</span>
<span class="sd">        will be established.</span>

<span class="sd">        :parameter called: mobile handoff numbr configured in UCm</span>
<span class="sd">        :parameter calling: calling number</span>
<span class="sd">        :parameter calltype: call type.  Possible values \n</span>
<span class="sd">            * 0 - Cellular</span>
<span class="sd">            * 1 - Mobile</span>
<span class="sd">        :parameter lineref: line index of the call to be switched.</span>

<span class="sd">        :returns: Callreference or False (if failed)</span>

<span class="sd">        &gt;&gt;&gt; ep.dmchandin(called=&#39;88002&#39;,lineref=1)</span>
<span class="sd">        &#39;0xb79fdd8&#39;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method dmchandin()&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lineref</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lineref</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span> <span class="ow">or</span> <span class="n">lineref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid line reference&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lineref</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">lineref</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid line reference&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;calling&#39;</span><span class="p">:</span> <span class="n">calling</span><span class="p">,</span>
                  <span class="s1">&#39;calltype&#39;</span><span class="p">:</span> <span class="n">calltype</span><span class="p">,</span>
                  <span class="s1">&#39;lineref&#39;</span><span class="p">:</span> <span class="n">lineref</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">DMC_HANDIN</span><span class="p">,</span> <span class="n">called</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">enable_mobile_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; enables mobile connect.</span>
<span class="sd">        Specific usage is for CUMC endpoints</span>

<span class="sd">        :returns: True or False</span>

<span class="sd">        &gt;&gt;&gt; ep.enable_mobile_connect()</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">ENABLE_MOBILE_CONNECT</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">disable_mobile_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; disables mobile connect.</span>
<span class="sd">        Specific usage is for CUMC endpoints</span>

<span class="sd">        :returns: True or False</span>

<span class="sd">        &gt;&gt;&gt; ep.enable_mobile_connect()</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_to_boolean</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">ENABLE_MOBILE_CONNECT</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_fax_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get fax-related information on a call</span>
<span class="sd">        Retrieve current information about a fax session on a call.</span>
<span class="sd">        If a call has more than one fax transmission, this method</span>
<span class="sd">        retrieves information about the last session.</span>

<span class="sd">        :parameter callref: call reference</span>

<span class="sd">        :returns: dictionary of fax call info with following field values.</span>
<span class="sd">            * state - state of the session.  Possible values \n</span>
<span class="sd">                * idle - fax session has not started.\n</span>
<span class="sd">                * connecting - fax terminals connecting.\n</span>
<span class="sd">                * negotiating - fax terminals negotiating a modem and speed.\n</span>
<span class="sd">                * sending - fax terminal sending a fax.\n</span>
<span class="sd">                * receiving - fax terminal receiving a fax.\n</span>
<span class="sd">                * done - fax session complete.\n</span>
<span class="sd">                * error - fax session did not complete but had an error.\n</span>
<span class="sd">            * page - page number currently being transferred.\n</span>
<span class="sd">            * modem - modem selected for transfer, v27, v29, v33, or v17.\n</span>
<span class="sd">            * rate -  rate selected for transfer, 2400, 4800, 7200, 9600,</span>
<span class="sd">                      12000, or 14400.\n</span>
<span class="sd">            * url - tiff file currently being transferred.</span>
<span class="sd">            * error - error information if state is error.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">GET_FAX_INFO</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call refernce&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_ice_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">ptype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixup</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get an endpoint ICE specific statistics.</span>
<span class="sd">        Can extract ICE specific parameters received from far end.</span>

<span class="sd">        :parameter callref: call reference.</span>
<span class="sd">        :parameter ptype: type of media like audio, video etc. if not used</span>
<span class="sd">                          session params will be displayed.</span>
<span class="sd">        :parameter subtype: in case of multiple video this field can be used to</span>
<span class="sd">                          specify type of video like slides, presentation etc.</span>
<span class="sd">                          default value is None.</span>
<span class="sd">        :parameter fixup: when this flag is given ICE Parameters received in</span>
<span class="sd">                          fixup SDP will be shown and if this is not set only</span>
<span class="sd">                          parameters received in main SDP will be shown.</span>

<span class="sd">        :returns: dictionary of fax call info with following field values.\n</span>
<span class="sd">            * candidates - shows all candidates received from far end in list</span>
<span class="sd">                           format.</span>
<span class="sd">            * ufrag - ufrag received from far end.</span>
<span class="sd">            * pwd - pwd received from far end.</span>
<span class="sd">            * options - options received from far end.</span>
<span class="sd">            * rem-cand - remote candidates recevied from far end.</span>
<span class="sd">            * ice-mismatch - &#39;true&#39; if ice-mismatch is received else &#39;false&#39;.</span>

<span class="sd">        &gt;&gt;&gt; ep1.get_ice_info(&#39;0xf13244&#39;)</span>
<span class="sd">            {&#39;candidates&#39;: &#39;&#39;,</span>
<span class="sd">             &#39;ice-mismatch&#39;: &#39;false&#39;,</span>
<span class="sd">             &#39;options&#39;: &#39;rtp+ecn&#39;,</span>
<span class="sd">             &#39;pwd&#39;: &#39;SypB+3lO0wbhmnRz4pJedeGS&#39;,</span>
<span class="sd">             &#39;rem-cand&#39;: &#39;&#39;,</span>
<span class="sd">             &#39;ufrag&#39;: &#39;ShfOWS&#39;}</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">ptype</span><span class="p">,</span>
                      <span class="s1">&#39;subtype&#39;</span><span class="p">:</span> <span class="n">subtype</span><span class="p">,</span>
                      <span class="s1">&#39;fixup&#39;</span><span class="p">:</span> <span class="n">fixup</span><span class="p">}</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">GET_ICE_INFO</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call refernce&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_ice_details</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get an endpoint ICE specific statistics.</span>
<span class="sd">        Can extract ICE specific parameters generated locally and</span>
<span class="sd">        received from far end.</span>


<span class="sd">        :parameter callref: call reference</span>

<span class="sd">        :returns: JSON of Hedge call info with following field values.\n</span>
<span class="sd">            * local-candidate and remote-candidate - shows all local and</span>
<span class="sd">              candidates received from far end in list format.</span>
<span class="sd">            * local-parm and remote-parm  - shows ufrag and password of</span>
<span class="sd">              local and remote</span>

<span class="sd">        &gt;&gt;&gt; ep1.get_ice_details(&#39;0xf13244&#39;)</span>
<span class="sd">        {&#39;AUDIO&#39;:</span>
<span class="sd">        {&#39;remote_parms&#39;: {</span>
<span class="sd">          &#39;passwd&#39;: &#39;&#39;,</span>
<span class="sd">          &#39;ufrag&#39;: &#39;4fa&#39;},</span>
<span class="sd">         &#39;local_candidates&#39;:[</span>
<span class="sd">         &#39;&#39;Ha6925ba 1 UDP 2130706431 10.105.37.186 21634 typ host&#39;,</span>
<span class="sd">          &#39;Sa6925ba 1 UDP 1694498815 10.105.37.186 21634 typ srflx raddr</span>
<span class="sd">           10.105.37.186 rport 21634&#39;,</span>
<span class="sd">          &#39;Ra6925ba 1 UDP 16777215 128.107.0.231 24000 typ relay raddr</span>
<span class="sd">           10.105.37.186 rport 21634&#39;],</span>
<span class="sd">        &#39;local_parms&#39;: {</span>
<span class="sd">                       &#39;passwd&#39;: &#39;52d1de0&#39;,</span>
<span class="sd">                       &#39;ufrag&#39;: &#39;077d4b9&#39;},</span>
<span class="sd">        &#39;remote_candidates&#39;: [</span>
<span class="sd">        &#39;Ha6925ba 1 UDP 2130706431 10.105.37.186 21899 typ host&#39;,</span>
<span class="sd">        &#39;Sa6925ba 1 UDP 1694498815 10.105.37.186 21899 typ srflx raddr</span>
<span class="sd">         10.105.37.186 rport 21899&#39;,</span>
<span class="sd">        &#39;Ra6925ba 1 UDP 16777215 128.107.0.231 24001 typ relay raddr</span>
<span class="sd">         10.105.37.186 rport 21899&#39;,</span>
<span class="sd">        &#39;vcs 1 UDP 16777470 128.107.0.231 42256 typ host&#39;]</span>
<span class="sd">              }</span>
<span class="sd">        }</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">call_ref</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">GET_ICE_DETAILS</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call refernce&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_ice_candidate_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get/Set the ICE candidate order list</span>

<span class="sd">        :parameter candidate: Is an order list which need to be set</span>
<span class="sd">              for next call.</span>
<span class="sd">              If list is None then it will return the current used list.</span>
<span class="sd">              If list has only empty string or empty list then the current</span>
<span class="sd">              order will be reset to Camelot default.</span>
<span class="sd">              If list has only member other than</span>
<span class="sd">              &quot;host&quot;,&quot;srflx&quot;,&quot;relay&quot; then api will raise ValueError exception.</span>
<span class="sd">        :returns: If input is None then, returns the current candiate order</span>
<span class="sd">            list used.</span>

<span class="sd">        &gt;&gt;&gt; ep1.vapi.config_ice_candidate_order()</span>
<span class="sd">        [u&#39;host&#39;, u&#39;srflx&#39;, u&#39;relay&#39;] #Current/Camelot default</span>

<span class="sd">        &gt;&gt;&gt; ep1.vapi.config_ice_candidate_order(</span>
<span class="sd">        candidate=[&#39;srflx&#39;,&#39;host&#39;,&#39;relay&#39;])</span>
<span class="sd">        [u&#39;srflx&#39;, u&#39;host&#39;, u&#39;relay&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ep1.vapi.config_ice_candidate_order()</span>
<span class="sd">        [u&#39;srflx&#39;, u&#39;host&#39;, u&#39;relay&#39;] # Currently set</span>

<span class="sd">        &gt;&gt;&gt; ep1.vapi.config_ice_candidate_order([&#39;&#39;])</span>
<span class="sd">        [] # reset to Camelot default</span>
<span class="sd">        &gt;&gt;&gt; ep1.vapi.config_ice_candidate_order()</span>
<span class="sd">        [u&#39;host&#39;, u&#39;srflx&#39;, u&#39;relay&#39;] #back to Camelot default</span>

<span class="sd">        For more information on how users can overwrite the above values</span>
<span class="sd">        and how camelot determines those explained in camelot wiki page:\n</span>
<span class="sd">        https://wiki.cisco.com/display/CAMELOT/ICE+and+TURN+support</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">operation</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">cand_present</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">candidate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">operation</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">candidate</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
                    <span class="n">cand_present</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;relay&quot;</span><span class="p">,</span> <span class="s2">&quot;host&quot;</span><span class="p">,</span> <span class="s2">&quot;srflx&quot;</span><span class="p">):</span>
                    <span class="n">cand_present</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid candidates&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cand_present</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">candidate</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;relay&quot;</span><span class="p">,</span> <span class="s2">&quot;host&quot;</span><span class="p">,</span> <span class="s2">&quot;srflx&quot;</span><span class="p">):</span>
                    <span class="n">cand_present</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;invalid candidates&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cand_present</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">cand_present</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">CONF_ICE_CAND</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">update_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">sdp_option</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        once the call is established update_call() helps, to</span>
<span class="sd">        send the mid call update message to the other end.</span>

<span class="sd">        :parameter call_ref: reference of the call</span>
<span class="sd">        :parameter sdp_option: it is string type parameter and it is optional\n</span>
<span class="sd">         * user can pass the parameter list to update the sdp portion of</span>
<span class="sd">           UPDATE message. Parameter list is Below:</span>

<span class="sd">             * audioport - it takes the following values:</span>
<span class="sd">                    * nonzero - audio port will be refreshed.</span>
<span class="sd">             * videoport - it takes the following values:</span>
<span class="sd">                    * nonzero - video port will be refreshed.</span>
<span class="sd">             * ipv4address - ipv4 address will be refreshed at the</span>
<span class="sd">                             session level.</span>
<span class="sd">             * vidpayloadtype - dynamic video payload type.</span>

<span class="sd">         *  Below are the examples:</span>
<span class="sd">              ipv4Address:10.105.37.185</span>
<span class="sd">              ipv4Address:10.105.37.185;audioport:nonzero;videoport:nonzero</span>
<span class="sd">              ipv4Address:10.105.37.185;vidpayloadtype:122</span>

<span class="sd">        :returns: True on success  otherwise False is returned.</span>
<span class="sd">                 For error the CamelotError exception is raised</span>

<span class="sd">        &gt;&gt;&gt; ep1.update_call(&#39;0x010a5650&#39;, &#39;ipv4Address:10.105.37.185&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call refernce&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sdp_option</span><span class="p">:</span>
            <span class="n">sdp_option</span> <span class="o">=</span> <span class="s1">&#39;null&#39;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">UPDATE_CALL</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">sdp_option</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_reinvite_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="o">=</span><span class="s1">&#39;null&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;408&#39;</span><span class="p">,</span>
                              <span class="n">reason_phrase</span><span class="o">=</span><span class="s1">&#39;Request Timeout&#39;</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span>
                              <span class="n">initial_invite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set reinvite response - set the response code for mid call reinvite</span>
<span class="sd">        or initial invite.</span>
<span class="sd">        The sip error response with the set response code and</span>
<span class="sd">        reason_phrase will be sent immediately after receiving invite (for re-</span>
<span class="sd">        invite also), meaning neither 100 Trying nor 180 ringing will be sent</span>
<span class="sd">        before responding with error response.</span>

<span class="sd">        `Refer the following wiki link for sample scripts and demo recording-</span>
<span class="sd">        &lt;https://wiki.cisco.com/display/CAMELOT/Simulated+endpoint+features+to</span>
<span class="sd">        +overcome+raw+endpoint+challenges#Simulatedendpointfeaturestoovercomeraw</span>
<span class="sd">        endpointchallenges-4xx/5XX/6XXforinitialinviteormid-callre-invite&gt;`_</span>

<span class="sd">        RE-INVITE</span>

<span class="sd">        When a mid call reinvite is received by endpoint, user can set what</span>
<span class="sd">        needs to be responded for it. It sets the response code to be</span>
<span class="sd">        considered only for a particular call or all calls of an endpoint.</span>
<span class="sd">        Also user can decide for how many times to repeat to send the</span>
<span class="sd">        response with the given value for the reinvites. \n</span>
<span class="sd">        If the call_ref is given, re-invite is responded with the configured</span>
<span class="sd">        response code value only for that call/dialog. if no call_ref is given,</span>
<span class="sd">        re-invite is responsed with the configured response code value for all</span>
<span class="sd">        the calls/dialogs and for each call the repeat value is set with the</span>
<span class="sd">        original value. i.e for example, if repeat is configured as 2 and no</span>
<span class="sd">        call_ref is given, for first call, the first two revinvite will be</span>
<span class="sd">        responded with the value. And again for second call, the first two</span>
<span class="sd">        reinvite will be responded with the value.</span>

<span class="sd">        :parameter call_ref:    call reference of a call.</span>

<span class="sd">        :parameter value:       value of SIP Response code.possible values:\n</span>
<span class="sd">                                * 0 - no resposne will be sent for re-invite</span>
<span class="sd">                                * any 4xx/5xx/6xx response code</span>

<span class="sd">        :parameter reason_phrase:  reason phrase with respect to the value.</span>
<span class="sd">                                   if value is given but no reason phrase, then</span>
<span class="sd">                                   camelot will send the standard reason phrase</span>
<span class="sd">                                   of the value.</span>

<span class="sd">        :parameter repeat:   It decides, for how many reinvites the configured</span>
<span class="sd">                             value should be considered.</span>
<span class="sd">                             Possible options are given below:\n</span>
<span class="sd">                             * 0 - configured value wont be considered and</span>
<span class="sd">                                   normal flow for reinvite will happen</span>
<span class="sd">                             * -1 - configured values will be considered for</span>
<span class="sd">                                  all mid call reinvites</span>
<span class="sd">                             * any valid integer.</span>
<span class="sd">                                If 4, for example,configured value will be sent</span>
<span class="sd">                                for 4 reinvites only.</span>

<span class="sd">        :parameter initial_invite: set response code, reason phrase and repeat</span>
<span class="sd">                values for initial invite or reinvite.default is for reinvite.</span>

<span class="sd">        :returns: On error, CamelotError Exception will be thrown.</span>

<span class="sd">        &gt;&gt;&gt; ep1.place_call(&#39;76553&#39;)</span>
<span class="sd">        &#39;0xf1706408&#39;</span>
<span class="sd">        &gt;&gt;&gt; ep1.set_reinvite_response(call_ref=&#39;0xf1706408&#39;,value=&#39;487&#39;,</span>
<span class="sd">        ...                           repeat=1)</span>
<span class="sd">        &gt;&gt;&gt; ep2.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;connected&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xaa2beb8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xaa2beb8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep2.hold(&#39;0xaa2beb8&#39;)</span>
<span class="sd">        True</span>

<span class="sd">        In the above case, ep1 will receive reinvite and respond with</span>
<span class="sd">        487 Request Terminated</span>

<span class="sd">        &gt;&gt;&gt; ep1.place_call(&#39;76558&#39;)</span>
<span class="sd">        &#39;0xf0f7d2b0&#39;</span>
<span class="sd">        &gt;&gt;&gt; ep3.enable_auto_answer(delay=0)</span>
<span class="sd">        &#39;enabled&#39;</span>
<span class="sd">        &gt;&gt;&gt; ep3.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;connected&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xaa2aea8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xaa2aea8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep3.hold(&#39;0xaa2aea8&#39;)</span>
<span class="sd">        True</span>

<span class="sd">        In the above case, ep1 will receive reinvite and respond with</span>
<span class="sd">        normal response (200 OK, if no internal errors).  Becasuse</span>
<span class="sd">        set_reinvite_response is not invoked and earlier we have set it</span>
<span class="sd">        only for that call.</span>

<span class="sd">        If the user wants to make the set_reinvite_response to</span>
<span class="sd">        work for all calls:</span>

<span class="sd">        &gt;&gt;&gt; ep1.set_reinvite_response(value=&#39;408&#39;, repeat=&#39;-1&#39;)</span>

<span class="sd">        This will make the endpoint to respond 408 Request Timeout for</span>
<span class="sd">        all the reinvites it receives.</span>

<span class="sd">        INITIAL INVITE</span>

<span class="sd">        When a initial invite is received by endpoint, user can set what</span>
<span class="sd">        needs to be responded for it. It sets the response code to be</span>
<span class="sd">        considered for all calls of an endpoint.</span>
<span class="sd">        Also user can decide for how many times to repeat to send the</span>
<span class="sd">        response with the given value for the initial invite. \n</span>
<span class="sd">        The call_ref should not be given in case of initial invite,</span>
<span class="sd">        initial invite is responsed with the configured response code value</span>
<span class="sd">        for all the calls and for each call the repeat value is</span>
<span class="sd">        set with the original value. i.e for example, if repeat is configured</span>
<span class="sd">        as 2 the first two initial invite will be</span>
<span class="sd">        responded with the value.</span>

<span class="sd">        &gt;&gt;&gt; ep2.set_reinvite_response(call_ref=&#39;0xf1706408&#39;,value=&#39;487&#39;,</span>
<span class="sd">        ...                           repeat=1, initial_invite=True)</span>
<span class="sd">        &gt;&gt;&gt; ep1.place_call(&#39;76553&#39;)</span>
<span class="sd">        &#39;0xf1706408&#39;</span>

<span class="sd">        &gt;&gt;&gt; ep1.get_calls()</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;disconnected&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xaa2beb8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xaa2beb8&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep1.get_calls()</span>
<span class="sd">        []</span>

<span class="sd">        In the above case, ep2 will receive invite and respond with</span>
<span class="sd">        487 Request Terminated</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method set_reinvite_response().&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">call_ref</span> <span class="o">!=</span> <span class="s1">&#39;null&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid Call Reference&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;408&#39;</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">reason_phrase</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Request Timeout&#39;</span><span class="p">:</span>
            <span class="n">reason_phrase</span> <span class="o">=</span> <span class="s1">&#39;null&#39;</span>

        <span class="k">if</span> <span class="n">initial_invite</span><span class="p">:</span>
            <span class="n">initial_invite</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial_invite</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span>
                  <span class="s1">&#39;reason_phrase&#39;</span><span class="p">:</span> <span class="n">reason_phrase</span><span class="p">,</span>
                  <span class="s1">&#39;repeat&#39;</span><span class="p">:</span> <span class="n">repeat</span><span class="p">,</span>
                  <span class="s1">&#39;initial_invite&#39;</span><span class="p">:</span> <span class="n">initial_invite</span>
                  <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span>
            <span class="n">camelot</span><span class="o">.</span><span class="n">SET_REINVITE_RESPONSE</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_confid_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the list of all AdHoc Conference ids and their active status.</span>
<span class="sd">        This command is supported for SIP TRUNK only.</span>

<span class="sd">        :returns: On error, CamelotError Exception will be thrown.</span>

<span class="sd">        &gt;&gt;&gt; ep1.get_confid_list()</span>
<span class="sd">        [{&#39;status&#39;: &#39;active&#39;, &#39;confid&#39;: &#39;111111&#39;},</span>
<span class="sd">         {&#39;status&#39;: &#39;inactive&#39;, &#39;confid&#39;: &#39;222222&#39;}]</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method get_confid_list().&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span>
            <span class="n">camelot</span><span class="o">.</span><span class="n">GET_CONFID_LIST</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear_inactive_conference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Clear all inactive conference ids from the list.</span>
<span class="sd">        This command is supported for SIP TRUNK only.</span>

<span class="sd">        :returns: On error, CamelotError Exception will be thrown.</span>

<span class="sd">        &gt;&gt;&gt; ep1.get_confid_list()</span>
<span class="sd">        [{&#39;status&#39;: &#39;active&#39;, &#39;confid&#39;: &#39;111111&#39;},</span>
<span class="sd">         {&#39;status&#39;: &#39;inactive&#39;, &#39;confid&#39;: &#39;222222&#39;}]</span>

<span class="sd">        &gt;&gt;&gt; ep1.clear_inactive_conference()</span>

<span class="sd">        &gt;&gt;&gt; ep1.get_confid_list()</span>
<span class="sd">        [{&#39;status&#39;: &#39;active&#39;, &#39;confid&#39;: &#39;111111&#39;}]</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method clear_inactive_conference().&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span>
            <span class="n">camelot</span><span class="o">.</span><span class="n">CLEAR_INACTIVE_CONFERENCE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_conf_calls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">confid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Retrieve current calls associated with a confid.</span>

<span class="sd">        The required confid can be picked from get_confid_list()</span>
<span class="sd">        This command is supported for SIP TRUNK only.</span>

<span class="sd">        :parameter confid:    confid of a AdHoc Conference</span>

<span class="sd">        :returns: A variable sized list. Each element in the list is a</span>
<span class="sd">                    camelot.response.Call object with following attributes:\n</span>
<span class="sd">                        :call_ref: call reference of call</span>
<span class="sd">                        :line: line associated with call</span>
<span class="sd">                        :state: current state of call</span>


<span class="sd">        &gt;&gt;&gt; ep1.get_confid_list()</span>
<span class="sd">        [{&#39;status&#39;: &#39;active&#39;, &#39;confid&#39;: &#39;111111&#39;},</span>
<span class="sd">         {&#39;status&#39;: &#39;inactive&#39;, &#39;confid&#39;: &#39;222222&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; ep1.get_conf_calls(confid=&#39;111111&#39;)</span>
<span class="sd">        [{&#39;CallState&#39;: &#39;connected&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xaa2beb8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xaa2beb8&#39;}</span>
<span class="sd">        {&#39;CallState&#39;: &#39;connected&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xbb2beb8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xbb2beb8&#39;}</span>
<span class="sd">        {&#39;CallState&#39;: &#39;connected&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xcc2beb8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xcc2beb8&#39;}</span>
<span class="sd">        {&#39;CallState&#39;: &#39;connected&#39;,</span>
<span class="sd">          &#39;Id&#39;: &#39;0xdd2beb8&#39;,</span>
<span class="sd">          &#39;Line&#39;: &#39;1&#39;,</span>
<span class="sd">          &#39;Ref&#39;: &#39;0xdd2beb8&#39;}]</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering method get_conf_calls().&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">confid</span> <span class="o">!=</span> <span class="s1">&#39;null&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">confid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid confid&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span>
            <span class="n">camelot</span><span class="o">.</span><span class="n">GET_CONF_CALLS</span><span class="p">,</span> <span class="n">confid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_conf_streams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">confid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the media streams associated with a confid.</span>

<span class="sd">        The required confid can be picked from get_confid_list().</span>
<span class="sd">        This command is supported for SIP TRUNK only.</span>

<span class="sd">        :parameter confid:    confid of a AdHoc Conference</span>

<span class="sd">        :returns: A variable sized list. Each element in the list is a</span>
<span class="sd">                    camelot.response.Stream object</span>


<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Entering get_conf_streams function&#39;</span><span class="p">)</span>

        <span class="c1"># if confid and self._is_valid_call_ref(confid):</span>
        <span class="c1">#    raise Exception(&quot;Invalid confid&quot;)</span>

        <span class="n">stream_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">GET_CONF_STREAMS</span><span class="p">,</span> <span class="n">confid</span><span class="p">)</span>
        <span class="n">ret_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_server_conn</span><span class="p">()</span><span class="o">.</span><span class="n">output_format</span> <span class="o">!=</span> <span class="s1">&#39;json&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stream_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stream</span> <span class="ow">in</span> <span class="n">stream_list</span><span class="p">:</span>
                    <span class="n">ret_stream</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;StrmID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;stream_ref&#39;</span><span class="p">]</span>
                    <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;CallId&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;call_ref&#39;</span><span class="p">]</span>
                    <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;Type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
                    <span class="n">stream_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stream_info</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="s1">&#39;stream_ref&#39;</span><span class="p">])</span>
                    <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;RemoteAddr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream_info</span><span class="p">[</span><span class="s1">&#39;address&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;open&#39;</span><span class="p">:</span>
                        <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;StreamStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Active&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;StreamStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Not Ready&#39;</span>
                    <span class="k">if</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;inbound&#39;</span><span class="p">:</span>
                        <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;Direction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Rx&#39;</span>
                        <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;RcvrCodec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;codec&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;direction&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;outbound&#39;</span><span class="p">:</span>
                        <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;Direction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Tx&#39;</span>
                        <span class="n">ret_stream</span><span class="p">[</span><span class="s1">&#39;SenderCodec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;codec&#39;</span><span class="p">)</span>

                    <span class="n">ret_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret_stream</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stream_list</span>

    <span class="k">def</span> <span class="nf">send_dtmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">dtmf_digits</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This funciton is applicable only fo CAS endpoint to send DTMF</span>
<span class="sd">        digits from a given call reference.</span>

<span class="sd">        :parameter call_ref: valid callreference</span>
<span class="sd">        :parameter dtmf_digits: DTMF digits to send. Valid ditits are:\n</span>
<span class="sd">                                * 0 - 9, A - D, * and #</span>
<span class="sd">        :return: True or False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call refernce&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dtmf_digits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;DTMF digits should not be empty&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">SEND_DTMF</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">dtmf_digits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup_fax_call_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">call_ref</span><span class="p">,</span> <span class="n">fax_profile</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function is applicable only for CAS endpoint to set fax</span>
<span class="sd">        options for a particular call.  Fax options are like enable interrupt,</span>
<span class="sd">        enable color, etc.,</span>

<span class="sd">        :parameter call_ref: valid call reference</span>
<span class="sd">        :parameter fax_profile: Object of FaxProfile class\n</span>
<span class="sd">                               The FaxProfile here takes LocalFaxId,</span>
<span class="sd">                               FaxHeadLine and MaxSpeed as</span>
<span class="sd">                               camelot.DivaFaxMaxSpeed\n</span>
<span class="sd">                               class DivaFaxMaxSpeed(Enum):\n</span>
<span class="sd">                                    DivaFaxMaxSpeedAutomatic = 0\n</span>
<span class="sd">                                    DivaFaxMaxSpeed2400 = 2400\n</span>
<span class="sd">                                    DivaFaxMaxSpeed4800 = 4800\n</span>
<span class="sd">                                    DivaFaxMaxSpeed7200 = 6200\n</span>
<span class="sd">                                    DivaFaxMaxSpeed9600 = 9600\n</span>
<span class="sd">                                    DivaFaxMaxSpeed14400 = 14400\n</span>
<span class="sd">                                    DivaFaxMaxSpeed33600 = 33600\n</span>
<span class="sd">        :return: True or Camelot exception\n</span>
<span class="sd">                 Possible exceptions are:\n</span>
<span class="sd">                 1. Interface error</span>
<span class="sd">                       * This will happen if something wrong with Diva SDK API</span>
<span class="sd">                 2. Invalid callrerence</span>
<span class="sd">                       * This will happen if call reference is not valid</span>

<span class="sd">        &gt;&gt;&gt; profile = FaxProfile()</span>
<span class="sd">        &gt;&gt;&gt; profile.diva_fax_options =</span>
<span class="sd">        [DivaFaxOptions.DivaFaxOptionEnableColor,</span>
<span class="sd">        DivaFaxOptions.DivaFaxOptionDisableECM]</span>
<span class="sd">        &gt;&gt;&gt; ep2.vapi.enable_auto_answer(delay=0)</span>
<span class="sd">        &gt;&gt;&gt; ep1.vapi.place_call(&#39;1002&#39;)</span>
<span class="sd">        &gt;&gt;&gt; &#39;0xfe211abef&#39;</span>
<span class="sd">        &gt;&gt;&gt; ep1.vapi.setup_fax_call_options(&#39;0xfe211abef&#39;, profile)</span>
<span class="sd">        &gt;&gt;&gt; True</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_ref</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_call_ref</span><span class="p">(</span><span class="n">call_ref</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid call refernce&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fax_profile</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fax_profile</span><span class="p">,</span> <span class="n">FaxProfile</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fax_profile</span><span class="o">.</span><span class="n">diva_fax_options</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fax_profile</span><span class="o">.</span><span class="n">diva_fax_options</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span>
                 <span class="nb">list</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fo</span><span class="p">,</span> <span class="n">DivaFaxOptions</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">fo</span> <span class="ow">in</span> <span class="n">fax_profile</span><span class="o">.</span><span class="n">diva_fax_options</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">camelot</span><span class="o">.</span><span class="n">CamelotError</span><span class="p">(</span><span class="s1">&#39;Invalid FaxOptions&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fax_profile</span><span class="o">.</span><span class="n">default_fax_speed</span><span class="p">,</span>
                              <span class="n">camelot</span><span class="o">.</span><span class="n">DivaFaxMaxSpeed</span><span class="p">):</span>
                <span class="n">fax_profile</span><span class="o">.</span><span class="n">default_fax_speed</span> <span class="o">=</span> \
                    <span class="n">camelot</span><span class="o">.</span><span class="n">DivaFaxMaxSpeed</span><span class="o">.</span><span class="n">DivaFaxMaxAutomatic</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_camelot</span><span class="p">(</span><span class="n">camelot</span><span class="o">.</span><span class="n">SETUP_FAX_CALL_OPTIONS</span><span class="p">,</span>
                                   <span class="n">call_ref</span><span class="p">,</span> <span class="n">fax_profile</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Camelot Python SDK v12.6.22.12.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../camelot.html" >camelot</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2013, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.
    </div>
  </body>
</html>